Functional programming
R, at its heart, is a functional programming (FP) language. This means that it provides many tools for the creation and manipulation of functions. In particular, R has what’s known as first class functions. You can do anything with functions that you can do with vectors: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.

The chapter starts by showing a motivating example, removing redundancy and duplication in code used to clean and summarise data. Then you’ll learn about the three building blocks of functional programming: anonymous functions, closures (functions written by functions), and lists of functions. These pieces are twined together in the conclusion which shows how to build a suite of tools for numerical integration, starting from very simple primitives. This is a recurring theme in FP: start with small, easy-to-understand building blocks, combine them into more complex structures, and apply them with confidence.

The discussion of functional programming continues in the following two chapters: functionals explores functions that take functions as arguments and return vectors as output, and function operators explores functions that take functions as input and return them as output.

Outline
Motivation motivates functional programming using a common problem: cleaning and summarising data before serious analysis.

Anonymous functions shows you a side of functions that you might not have known about: you can use functions without giving them a name.

Closures introduces the closure, a function written by another function. A closure can access its own arguments, and variables defined in its parent.

Lists of functions shows how to put functions in a list, and explains why you might care.

Numerical integration concludes the chapter with a case study that uses anonymous functions, closures and lists of functions to build a flexible toolkit for numerical integration.

Prequisites
You should be familiar with the basic rules of lexical scoping, as described in lexical scoping. Make sure you’ve installed the pryr package with install.packages("pryr")


